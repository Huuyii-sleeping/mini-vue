# 编译模块实现

## 整体流程

1. 模板解析的过程（Parse）
   - 将模板字符串 -> AST（抽象语法树）
     - 使用正则表达式和字符串解析将模板字符串分解成tokens
     - 解析HTML标签，属性，指令和文本内容
     - 构建AST节点树，包含元素节点，文本节点，表达式节点等
     - 处理Vue特有的语法 v-if v-for等指令
2. 优化阶段（Optimize）
   - 标记静态节点以提高渲染性能
     - 遍历AST标记静态节点（固定不变节点）
     - 标记静态根节点（子节点是静态节点）
     - 在后续更新过程中跳过静态节点的比对
3. 代码生成阶段（Generate）
   - 将AST转换成可执行的渲染函数代码
     - 递归遍历AST生成渲染函数代码字符串
     - 处理节点类型
     - 处理指令和特殊属性
4. 创建渲染函数
   - 将生成的代码转换成可执行的函数
     - 将代码字符串转换成函数
     - 该函数执行会创建虚拟DOM
     - 最终得到渲染函数

### Prase

#### 解析删除操作原因

在完成模板解析后会删除模板字符串，和相关的中间的代码

- 内存优化
- 安全性考虑
- 性能优化
  - 减少GC压力
  - 提高缓存效率
  - 避免不必要的字符串操作
- 架构设计原则
  - 关注点分离
    - Prase阶段完成 只关注依赖AST不关心原始模板
  - 不可变数据流
    - 确保编译管道各阶段输入输出的明确性
  - 简化调式信息
    - 生产环境下只需保留必要错误信息而并非完整的信息

#### 实现解析插值类型

将 `{{message}}`进行解析

实现将message进行裁剪形成只有对应的content

将没有的括号 标签进行裁剪

```ts
import { NodeTypes } from "./ast"

export function baseParse(content: string) {
    const context = createPraseContent(content)
    return createRoot(parseChildren(context))
}

function parseChildren(context) {
    const nodes: any = []
    let node 
    if (context.source.startsWith('{{')) {
        node = parseInterpolation(context)
    }
    nodes.push(node)
    return nodes
}

function parseInterpolation(context) {

    // 通过对content的解析得到的
    // {{message}} 
    const openDelimiter = '{{'
    const closeDelimiter = '}}'
    // mean : 从第二个开始寻找 一直找到}}的开始的索引 == 9
    const closeIndex = context.source.indexOf(closeDelimiter, openDelimiter.length)
    advanceBy(context, openDelimiter.length)

    const rawContentLength = closeIndex - openDelimiter.length
    const rawContent = context.source.slice(0, rawContentLength)
    // 取出边缘的空格
    const content = rawContent.trim()
    advanceBy(context, rawContentLength - closeDelimiter.length)

    return {
        type: NodeTypes.INTERPOLATION,
        content: {
            type: NodeTypes.SIMPLE_EXPRESSION,
            content: content
        }
    }
}

function createRoot(children) {
    return {
        children
    }
}

function createPraseContent(content) {
    return {
        source: content
    }
}

function advanceBy(context, length) {
    context.source = context.source.slice(length)
}

```

#### 实现解析element类型

`<div></div>` element类型解析

使用正则进行解析 找到正确的标签以及标签的位置进行解析

最后要有删除操作 进行标签的删除

```ts
function parseElement(context) {

    // 解析 tag
    const element = parseTag(context,TagType.START)
    parseTag(context,TagType.END)
    return element
}

function parseTag(context,type:TagType) {
    // 匹配开始（找到Tag）结尾（进行删除）的标签
    const match: any = /^<\/?([a-z]*)/.exec(context.source)
    const tag = match[1]
    // 删除 处理成功代码
    advanceBy(context, match[0].length)
    advanceBy(context, 1)

    if(type === TagType.END)return 

    return {
        type: NodeTypes.ELEMENT,
        tag,
    }
}
```

#### 实现解析text类型

实现text类型的解析

不是上面的两种情况，就是解析text类型

```ts
function parseText(context) {
    // 获取 content
    const content = parseTextData(context,context.source.length)

    return {
        type: NodeTypes.TEXT,
        content
    }
}

function parseTextData(context,length) {
    const content = context.source.slice(0, length)
    advanceBy(context, content.length)
    return content
}
```

解析成功之后记得应该将解析的东西进行删除

#### 实现解析三种类型

验证正确的位置

`<div>hi,{{message}}</div>`

当我们进行解析的时候，

1. 我们解析element 
   1. 解析的时候我们发现将 div 进行 advanced
   2. 剩下的需要放在children当中解析
2. 发现 text类型 进行解析
   1. 解析将hi，进行 advanced
3. 但是 解析text的时候我们直接return了不能继续解析，这时候我们就考虑使用循环的形式，将所有的信息完全解析出来

```ts
function parseChildren(context, ancestors) {
    const nodes: any = []
    while (!isEnd(context, ancestors)) {
        let node
        const s = context.source
        if (s.startsWith('{{')) {
            node = parseInterpolation(context)
        } else if (s[0] === '<') {
            if (/[a-z]/i.test(s[1])) {
                node = parseElement(context,ancestors)
            }
        }

        // text类型的解析
        if (!node) {
            node = parseText(context)
        }
        nodes.push(node)
    }
    return nodes
}

function isEnd(context,ancestors) {
    const s = context.source
    if(s.startsWith('</')){
        for(let i = 0;i<ancestors.length;i++){
            const tag = ancestors[i].tag
            if(s.slice(2,2+tag.length) === tag){
                return true
            }
        }
    }
    return !s
}
```

这里我们使用类似栈的结构就是想避免这种情况

`<div><span></div>` 遇见我们能够及时的抛出错误

能够保证标签是完整的

```ts
function parseElement(context,ancestors) {

    // 解析 tag
    const element: any = parseTag(context, TagType.START)
    ancestors.push(element)
    element.children = parseChildren(context, ancestors)
    ancestors.pop()

    // 观察 element.tag 和 content.source
    if(context.source.slice(2,2+element.tag.length) === element.tag){
        parseTag(context, TagType.END)
    }else{
        throw new Error(`缺少结束标签${element.tag}`)
    }
    
    return element
}
```

