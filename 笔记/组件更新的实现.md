# 组件的更新

组件的props的更新

判断是不是有对应的更新的操作

```ts
    function processComponent(n1, n2, container, parentComponent, anchor) {
        if (!n1) {
            mountComponent(n2, container, parentComponent, anchor) // 进行组件的挂载
        } else {
            updateComponent(n1, n2)
        }
    }
```

进行更新操作

update 是收集的effect里面函数 用来进行更新操作

```ts
    function updateComponent(n1, n2) {
        const instance = (n2.component = n1.component)
        if (shouleUpdateComponent(n1, n2)) {
            instance.next = n2
            instance.update()
        } else {
            n2.el = n1.el
            instance.vnode = n2
        }
    }
```

```ts
else {
                // 需要更新之后的新的虚拟节点
                const { next, vnode } = instance
                if (next) {
                    next.el = vnode.el
                    updateComponentPreRender(instance, next)
                }
                const { proxy } = instance
                const subTree = instance.render.call(proxy)
                const preSubTree = instance.subTree
                instance.subTree = subTree
                patch(preSubTree, subTree, container, instance, anchor)
            }
```

将原来的节点进行设置 更新

```ts
    function updateComponentPreRender(instance, nextVnode) {
        instance.vnode = nextVnode
        instance.next = null
        instance.props = nextVnode.props
    }
```

# 注意一个性能问题

当我们这么实现的时候，当我们点击使用or循环更新props

我们会重复进行很多的update操作，但是实际上我们呢只需要更新最后一次，如何解决这个性能问题？？

可以在微任务当中进行组件的更新

形成一个异步的更新操作

当props发生变化的时候，component是没有进行改变的

Vue3视图更新是异步操作，我们不需要进行频繁的更新

```ts
// 设置effect 的scheduler

const queue: any[] = []
let isFlushPending = false

// 获取更新之后的组件的实例
export function nextTick(fn) { 
    // 微任务延迟，将任务放入微任务队列，等到当前同步代码执行完毕之后在进行批量的处理
    // 性能优势： 合并多个组件更新到一次DOM操作中，减少重排/重绘次数
    return fn ? Promise.resolve().then(fn) : Promise.resolve()
}

export function queueJobs(job) {
    if ((queue).includes(job)) { //保证不会重复的执行
        (queue).push(job)
    }
    queueFlush()
}

function queueFlush() {
    if (isFlushPending) return // 防止重复的调度
    isFlushPending = true
    nextTick(flushJob)
}

function flushJob() {
    isFlushPending = false
    let job
    while (job = queue.shift()) {
        job && job()
    }
}
```

数据变化 -> 触发effect -> 生成job -> 调用queueJobs

Vue3 使用微任务队列 + 任务去重  批量更新，避免重复渲染 依赖响应式系统的自动触发

注意nextTick的本质就是Promise.resolve() 能够将目标函数放到微任务的队列当中